import { IPricesContractAdapter } from "@redstone-finance/sdk";
import { hexlify, hexZeroPad } from "ethers/lib/utils";
import { readFileSync } from "fs";
import {
  Account,
  BytesLike,
  ContractFactory,
  DeployContractOptions,
  StorageSlot,
} from "fuels";
import path from "path";
import { Prices } from "../autogenerated";
import { PricesConfigurables } from "../autogenerated/Prices";
import { FuelContractConnector } from "../FuelContractConnector";
import { FuelPricesContractAdapter } from "./FuelPricesContractAdapter";
import { FuelPricesContract } from "./FuelPricesContractConnector";

const PRICES_CONTRACT_BINARY = "../autogenerated/prices.bin";

export interface PricesContractDeployParameters {
  allowedSigners: string[];
  signerCountThreshold: number;
  contractBinary?: Promise<Buffer>;
  fakeTimestamp?: number;
  salt?: BytesLike;
}

export class FuelPricesContractDeployer extends FuelContractConnector<IPricesContractAdapter> {
  private contract?: FuelPricesContract;

  constructor(
    wallet: Account,
    private parameters: PricesContractDeployParameters
  ) {
    super(wallet);
  }

  async getContract(): Promise<FuelPricesContract> {
    if (this.contract) {
      return this.contract;
    }

    this.contract = await this.deployPricesContract();

    return this.contract;
  }

  async getAdapter(): Promise<IPricesContractAdapter> {
    return new FuelPricesContractAdapter(
      await this.getContract(),
      this.getGasLimit()
    );
  }

  private async deployPricesContract(): Promise<FuelPricesContract> {
    let bytecode = await this.parameters.contractBinary;

    if (!bytecode) {
      const pricesPath = path.join(__dirname, PRICES_CONTRACT_BINARY);
      bytecode = readFileSync(pricesPath);
    }

    const factory = new ContractFactory(bytecode, Prices.abi, this.wallet);
    const configurableConstants: PricesConfigurables = {
      SIGNER_COUNT_THRESHOLD: this.parameters.signerCountThreshold,
      ALLOWED_SIGNERS: this.makeAllowedSigners(),
    };
    const options: DeployContractOptions = {
      storageSlots: this.getStorageSlots(),
      configurableConstants,
    };

    if (this.parameters.salt) {
      options["salt"] = this.parameters.salt;
    }

    const deployResult = await factory.deploy<FuelPricesContract>(options);
    const { contract } = await deployResult.waitForResult();

    return contract;
  }

  private makeAllowedSigners() {
    const HEX_ZERO = "0x00";

    return [
      ...this.parameters.allowedSigners.slice(0, 6),
      HEX_ZERO,
      HEX_ZERO,
      HEX_ZERO,
      HEX_ZERO,
      HEX_ZERO,
      HEX_ZERO,
    ]
      .slice(0, 6)
      .map((signer) => hexZeroPad(signer, 32)) as [
      string,
      string,
      string,
      string,
      string,
      string,
    ];
  }

  private getStorageSlots() {
    const FAKE_TIMESTAMP_KEY = "0x66616b655f74696d657374616d70"; // fake_timestamp
    const storageSlots: StorageSlot[] = [];

    if (this.parameters.fakeTimestamp != null) {
      storageSlots.push({
        key: FAKE_TIMESTAMP_KEY,
        value: hexlify(this.parameters.fakeTimestamp),
      });
    }

    return Prices.storageSlots.concat(
      storageSlots.map(({ key, value }) => {
        return {
          key: hexZeroPad(key, 32),
          value: hexZeroPad(value, 32),
        };
      })
    );
  }
}
