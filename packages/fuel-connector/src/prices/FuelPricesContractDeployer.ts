import { BytesLike } from "@ethersproject/bytes";
import { Interface, JsonAbi } from "@fuel-ts/abi-coder";
import { CreateTransactionRequest, Provider } from "@fuel-ts/providers";
import { StorageSlot } from "@fuel-ts/transactions";
import { Account, WalletUnlocked } from "@fuel-ts/wallet";
import { IPricesContractAdapter } from "@redstone-finance/sdk";
import { readFileSync } from "fs";
import { BN, ContractFactory, WalletLocked, hexZeroPad, hexlify } from "fuels";
import path from "path";
import { FuelContractConnector } from "../FuelContractConnector";
import { PricesAbi__factory } from "../autogenerated";
import { FuelPricesContractAdapter } from "./FuelPricesContractAdapter";
import { FuelPricesContract } from "./FuelPricesContractConnector";

const PRICES_CONTRACT_BINARY = "../autogenerated/prices.bin";

export interface PricesContractDeployParameters {
  signers: string[];
  signerCountThreshold: number;
  contractBinary?: Promise<Buffer>;
  fakeTimestamp?: number;
  salt?: BytesLike;
}

type DeployContractOptions = {
  salt?: BytesLike;
  storageSlots?: StorageSlot[];
  stateRoot?: BytesLike;
};

export class FuelPricesContractDeployer extends FuelContractConnector<IPricesContractAdapter> {
  private contract?: FuelPricesContract;

  constructor(
    wallet: WalletUnlocked | WalletLocked,
    private parameters: PricesContractDeployParameters
  ) {
    super(wallet);
  }

  async getContract(): Promise<FuelPricesContract> {
    if (this.contract) {
      return this.contract;
    }

    this.contract = await this.deployPricesContract();

    return this.contract;
  }

  async getAdapter(): Promise<IPricesContractAdapter> {
    return new FuelPricesContractAdapter(
      await this.getContract(),
      this.getGasLimit()
    );
  }

  private async deployPricesContract(): Promise<FuelPricesContract> {
    let bytecode = await this.parameters.contractBinary;

    if (!bytecode) {
      const pricesPath = path.join(__dirname, PRICES_CONTRACT_BINARY);
      bytecode = readFileSync(pricesPath);
    }

    const factory = new PricesContractFactory(
      bytecode,
      PricesAbi__factory.abi,
      this.wallet!,
      this.getGasLimit()
    );
    const storageSlots = this.getStorageSlots();

    const options: DeployContractOptions = { storageSlots };

    if (this.parameters.salt) {
      options["salt"] = this.parameters.salt;
    }

    const contract = (await factory.deployContract(
      options
    )) as unknown as FuelPricesContract;

    await contract.functions
      .init(
        this.parameters.signers.map((signer) => hexZeroPad(signer, 32)),
        this.parameters.signerCountThreshold,
        0
      )
      .txParams({
        gasPrice: 1,
        gasLimit: this.getGasLimit(),
      })
      .call();

    return contract;
  }

  private getStorageSlots() {
    const FAKE_TIMESTAMP_KEY = "0x66616b655f74696d657374616d70"; // fake_timestamp
    const storageSlots = [];

    if (this.parameters.fakeTimestamp != null) {
      storageSlots.push({
        key: FAKE_TIMESTAMP_KEY,
        value: hexlify(this.parameters.fakeTimestamp),
      });
    }

    return storageSlots.map(({ key, value }) => {
      return {
        key: hexZeroPad(key, 32),
        value: hexZeroPad(value, 32),
      };
    });
  }
}

class PricesContractFactory extends ContractFactory {
  constructor(
    bytecode: BytesLike,
    abi: JsonAbi | Interface,
    walletOrProvider: Account | Provider | null,
    private gasLimit: number
  ) {
    super(bytecode, abi, walletOrProvider);
  }

  override createTransactionRequest(
    deployContractOptions?: DeployContractOptions
  ): {
    contractId: string;
    transactionRequest: CreateTransactionRequest;
  } {
    const { contractId, transactionRequest } = super.createTransactionRequest(
      deployContractOptions
    );

    transactionRequest.gasLimit = new BN(this.gasLimit);
    transactionRequest.gasPrice = new BN(1);

    return { contractId, transactionRequest };
  }
}
