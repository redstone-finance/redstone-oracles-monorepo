import { AnchorProvider, Program, Wallet, web3 } from "@coral-xyz/anchor";
import { SplitPayloads } from "@redstone-finance/sdk";
import { loggerFactory, MultiExecutor } from "@redstone-finance/utils";
import { Connection, Keypair, PublicKey, Transaction } from "@solana/web3.js";
import { PriceAdapter } from "./_autogenerated/price_adapter";
import * as idl from "./_autogenerated/price_adapter.json";
import {
  ALL_EXECUTIONS_TIMEOUT_MS,
  SINGLE_EXECUTION_TIMEOUT_MS,
} from "./SolanaConnectionBuilder";
import { PriceData } from "./types";
import { makeFeedIdBytes, makePriceSeed } from "./utils";

export class PriceAdapterContract {
  readonly program: Program<PriceAdapter>;
  private logger = loggerFactory("solana-price-adapter-contract");

  static createMultiContract(
    connection: Connection,
    priceAdapterObjectId: string,
    keypair?: Keypair
  ) {
    return MultiExecutor.createForSubInstances(
      connection,
      (conn) => new PriceAdapterContract(conn, priceAdapterObjectId, keypair),
      {
        getUniqueSignerThreshold: MultiExecutor.ExecutionMode.AGREEMENT,
        writePrices: MultiExecutor.ExecutionMode.RACE,
        getPriceData: MultiExecutor.ExecutionMode.AGREEMENT,
      },
      {
        ...MultiExecutor.DEFAULT_CONFIG,
        singleExecutionTimeoutMs: SINGLE_EXECUTION_TIMEOUT_MS,
        allExecutionsTimeoutMs: ALL_EXECUTIONS_TIMEOUT_MS,
      }
    );
  }

  constructor(
    connection: Connection,
    address: string,
    private keypair?: Keypair
  ) {
    const priceAdapter = { ...idl, address } as PriceAdapter;
    this.program = new Program(
      priceAdapter,
      new AnchorProvider(
        connection,
        keypair ? new Wallet(keypair) : Wallet.local()
      )
    );
  }

  private getPriceDataAccount(feedId: string): web3.PublicKey {
    return web3.PublicKey.findProgramAddressSync(
      [makePriceSeed(), makeFeedIdBytes(feedId)],
      this.program.programId
    )[0];
  }

  public getPriceData(feedId: string): Promise<PriceData> {
    const address = this.getPriceDataAccount(feedId);

    return this.program.account.priceData.fetch(address, "processed");
  }

  public async writePrices(payloads: SplitPayloads<string>) {
    const publicKey = this.program.provider.publicKey;
    if (!publicKey || !this.keypair) {
      throw new Error("Provider or keypair is empty");
    }

    const transactions = await Promise.all(
      Object.entries(payloads).map(([feedId, payload]) =>
        this.writePriceTx(publicKey, feedId, payload)
      )
    );

    if (!this.program.provider.sendAll) {
      throw new Error("sendAll method is not implemented");
    }

    const signers = [this.keypair];
    const signatures = await this.program.provider.sendAll(
      transactions.map((tx) => ({ tx, signers })),
      { skipPreflight: true, commitment: "processed" }
    );

    this.logger.log(`Sent transactions: [${signatures.toString()}]`);

    return signatures[signatures.length - 1];
  }

  private async writePriceTx(user: PublicKey, feedId: string, payload: string) {
    const ix = await this.program.methods
      .writePrice(
        Array.from(makeFeedIdBytes(feedId)),
        Buffer.from(payload, "hex")
      )
      .accountsStrict({
        user,
        priceAccount: this.getPriceDataAccount(feedId),
        systemProgram: web3.SystemProgram.programId,
      })
      .instruction();

    const tx = new Transaction();
    tx.add(ix);

    return tx;
  }

  public async getUniqueSignerThreshold(): Promise<number> {
    return (await this.program.methods.uniqueSignersCount().view()) as number;
  }
}
