import { AnchorProvider, Program, Wallet, web3 } from "@coral-xyz/anchor";
import { ContractParamsProvider } from "@redstone-finance/sdk";
import { loggerFactory, MultiExecutor } from "@redstone-finance/utils";
import { Connection, Keypair, PublicKey } from "@solana/web3.js";
import { PriceAdapter } from "./_autogenerated/price_adapter";
import * as idl from "./_autogenerated/price_adapter.json";
import { DEFAULT_SOLANA_CONFIG } from "./config";
import {
  ALL_EXECUTIONS_TIMEOUT_MS,
  SINGLE_EXECUTION_TIMEOUT_MS,
} from "./SolanaConnectionBuilder";
import { SolanaTxDeliveryMan } from "./SolanaTxDeliveryMan";
import { PriceData } from "./types";
import { makeFeedIdBytes, makePriceSeed } from "./utils";

export class PriceAdapterContract {
  readonly program: Program<PriceAdapter>;
  private logger = loggerFactory("solana-price-adapter-contract");

  static createMultiContract(
    connection: Connection,
    priceAdapterObjectId: string,
    keypair?: Keypair
  ) {
    const txDeliveryMan = keypair
      ? SolanaTxDeliveryMan.createMultiTxDeliveryMan(
          connection,
          keypair,
          DEFAULT_SOLANA_CONFIG
        )
      : undefined;

    return MultiExecutor.createForSubInstances(
      connection,
      (conn) =>
        new PriceAdapterContract(
          conn,
          priceAdapterObjectId,
          txDeliveryMan,
          keypair
        ),
      {
        getUniqueSignerThreshold: MultiExecutor.ExecutionMode.AGREEMENT,
        getPriceData: MultiExecutor.ExecutionMode.AGREEMENT,
      },
      {
        ...MultiExecutor.DEFAULT_CONFIG,
        singleExecutionTimeoutMs: SINGLE_EXECUTION_TIMEOUT_MS,
        allExecutionsTimeoutMs: ALL_EXECUTIONS_TIMEOUT_MS,
      }
    );
  }

  constructor(
    connection: Connection,
    address: string,
    private readonly txDeliveryMan: SolanaTxDeliveryMan | undefined,
    keypair?: Keypair
  ) {
    const priceAdapter = { ...idl, address } as PriceAdapter;
    this.program = new Program(
      priceAdapter,
      new AnchorProvider(
        connection,
        keypair ? new Wallet(keypair) : Wallet.local()
      )
    );
  }

  private getPriceDataAccount(feedId: string): web3.PublicKey {
    return web3.PublicKey.findProgramAddressSync(
      [makePriceSeed(), makeFeedIdBytes(feedId)],
      this.program.programId
    )[0];
  }

  public getPriceData(feedId: string): Promise<PriceData> {
    const address = this.getPriceDataAccount(feedId);

    return this.program.account.priceData.fetch(address, "processed");
  }

  public async writePrices(paramsProvider: ContractParamsProvider) {
    const publicKey = this.program.provider.publicKey;
    if (!publicKey) {
      throw new Error("Public key not set.");
    }
    if (!this.txDeliveryMan) {
      throw new Error("Can't write prices, TxDeliveryMan not set");
    }

    const retryFetch = async (feedIds: string[]) => {
      this.logger.debug(`Fetching payloads for [${feedIds.toString()}].`);
      const provider = ContractParamsProvider.copyForFeedIds(
        paramsProvider,
        feedIds
      );

      const timestamp = Date.now();
      const { payloads } = ContractParamsProvider.extractMissingValues(
        await provider.prepareSplitPayloads({
          metadataTimestamp: timestamp,
          withUnsignedMetadata: true,
        }),
        this.logger
      );

      return await Promise.all(
        Object.entries(payloads).map(async ([feedId, payload]) => ({
          ix: await this.writePriceTx(
            this.program.provider.publicKey!,
            feedId,
            payload
          ),
          id: feedId,
        }))
      );
    };

    const txSignatures = await this.txDeliveryMan.sendTransactions(
      paramsProvider.getDataFeedIds(),
      retryFetch.bind(this)
    );

    this.logger.log(`Sent transactions [${txSignatures.toString()}].`);
    return txSignatures[txSignatures.length - 1];
  }

  private async writePriceTx(user: PublicKey, feedId: string, payload: string) {
    return await this.program.methods
      .writePrice(
        Array.from(makeFeedIdBytes(feedId)),
        Buffer.from(payload, "hex")
      )
      .accountsStrict({
        user,
        priceAccount: this.getPriceDataAccount(feedId),
        systemProgram: web3.SystemProgram.programId,
      })
      .instruction();
  }

  public async getUniqueSignerThreshold(): Promise<number> {
    return (await this.program.methods.uniqueSignersCount().view()) as number;
  }
}
