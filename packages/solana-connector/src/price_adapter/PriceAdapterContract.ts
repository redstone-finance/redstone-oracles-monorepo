import { Program, web3 } from "@coral-xyz/anchor";
import { MultiExecutor, RedstoneCommon } from "@redstone-finance/utils";
import { Connection, PublicKey } from "@solana/web3.js";
import { PriceAdapter } from "../_autogenerated/price_adapter";
import * as idl from "../_autogenerated/price_adapter.json";
import {
  ALL_EXECUTIONS_TIMEOUT_MS,
  BLOCK_NUMBER_EXECUTION_TIMEOUT_MS,
  SINGLE_EXECUTION_TIMEOUT_MS,
} from "../SolanaConnectionBuilder";
import { PriceData } from "../types";
import { makeFeedIdBytes, makePriceSeed } from "../utils";
import { AnchorReadonlyProvider } from "./AnchorReadonlyProvider";

export class PriceAdapterContract {
  readonly program: Program<PriceAdapter>;

  static createMultiContract(
    connection: Connection,
    address: string,
    accountForSimulations?: PublicKey
  ) {
    const ceilMedianConsensusExecutor =
      new MultiExecutor.CeilMedianConsensusExecutor(
        MultiExecutor.DEFAULT_CONFIG.consensusQuorumRatio,
        BLOCK_NUMBER_EXECUTION_TIMEOUT_MS
      );
    return MultiExecutor.createForSubInstances(
      connection,
      (conn) => new PriceAdapterContract(conn, address, accountForSimulations),
      {
        getUniqueSignerThreshold: MultiExecutor.ExecutionMode.AGREEMENT,
        getPriceData: MultiExecutor.ExecutionMode.AGREEMENT,
        program: {
          provider: {
            connection: {
              getSlot: ceilMedianConsensusExecutor,
            },
          },
        },
      },
      {
        ...MultiExecutor.DEFAULT_CONFIG,
        singleExecutionTimeoutMs: SINGLE_EXECUTION_TIMEOUT_MS,
        allExecutionsTimeoutMs: ALL_EXECUTIONS_TIMEOUT_MS,
      }
    );
  }

  constructor(
    connection: Connection,
    address: string,
    accountForSimulations?: PublicKey
  ) {
    const priceAdapter = { ...idl, address } as PriceAdapter;
    this.program = new Program(
      priceAdapter,
      new AnchorReadonlyProvider(connection, accountForSimulations)
    );
  }

  private getPriceDataAccount(feedId: string): web3.PublicKey {
    return web3.PublicKey.findProgramAddressSync(
      [makePriceSeed(), makeFeedIdBytes(feedId)],
      this.program.programId
    )[0];
  }

  public async getPriceData(feedId: string, slot?: number): Promise<PriceData> {
    await this.waitForSlot(slot, `getPriceData for ${feedId}`);

    const address = this.getPriceDataAccount(feedId);
    const response = await this.program.provider.connection.getAccountInfo(
      address,
      { minContextSlot: slot }
    );

    if (response == null) {
      throw new Error(`Could not fetch data for account ${address.toBase58()}`);
    }

    return await this.program.coder.accounts.decode("priceData", response.data);
  }

  public async writePriceTx(user: PublicKey, feedId: string, payload: string) {
    return await this.program.methods
      .writePrice(
        Array.from(makeFeedIdBytes(feedId)),
        Buffer.from(payload, "hex")
      )
      .accountsStrict({
        user,
        priceAccount: this.getPriceDataAccount(feedId),
        systemProgram: web3.SystemProgram.programId,
      })
      .instruction();
  }

  public async getUniqueSignerThreshold(slot?: number): Promise<number> {
    await this.waitForSlot(slot, `getUniqueSignerThreshold`);
    return (await this.program.methods
      .uniqueSignersCount()
      .view({ minContextSlot: slot })) as number;
  }

  async waitForSlot(slot?: number, description?: string) {
    await RedstoneCommon.waitForBlockNumber(
      () => this.program.provider.connection.getSlot(),
      slot,
      description
    );
  }
}
