import { BlockWithTransactions, TransactionResponse } from "@ethersproject/abstract-provider";
import { HttpClient } from "@redstone-finance/http-client";
import { RedstoneCommon } from "@redstone-finance/utils";
import { AxiosRequestConfig } from "axios";
import { BigNumber, BigNumberish, ethers } from "ethers";
import {
  BytesLike,
  getAddress,
  getContractAddress,
  hexlify,
  hexValue,
  hexZeroPad,
} from "ethers/lib/utils";

type EthereumRpcRequest = {
  jsonrpc: "2.0";
  method: string;
  params: unknown[];
  id: number;
};

type EthereumRpcResponse<T> = {
  jsonrpc: "2.0";
  id: number;
  result: T;
  error?: { code: number; message: string };
};

type EthereumBlock = {
  hash: string;
  parentHash: string;
  sha3Uncles: string;
  stateRoot: string;
  transactionsRoot: string;
  receiptsRoot: string;
  number: string;
  gasUsed: string;
  gasLimit: string;
  extraData: string;
  logsBloom: string;
  timestamp: string;
  difficulty: string;
  totalDifficulty: string;
  uncles: string[];
  transactions: string[];
  size: string;
  mixHash: string;
  nonce: string;
  baseFeePerGas: string;
  miner: string;
  withdrawals: string[];
  withdrawalsRoot: string;
  blobGasUsed: string;
  excessBlobGas: string;
  parentBeaconBlockRoot: string;
};

type TransactionReceipt = {
  transactionHash: string; // The hash of the transaction
  transactionIndex: string; // The transaction index position in the block (hex string)
  blockHash: string; // The hash of the block containing this transaction
  blockNumber: string; // The block number containing this transaction (hex string)
  from: string; // The address of the sender
  to: string | null; // The address of the receiver (null when contract creation)
  cumulativeGasUsed: string; // The total gas used when this transaction was executed in the block (hex string)
  gasUsed: string; // The gas used by this specific transaction alone (hex string)
  contractAddress: string | null; // The contract address created, if this was a contract creation transaction
  logs: LogEntry[]; // Array of logs generated by this transaction
  logsBloom: string; // Bloom filter for light clients to quickly retrieve related logs (hex string)
  effectiveGasPrice: string;
  type?: string;
  status?: string; // Either "0x1" for success or "0x0" for failure (optional, may be missing on older Ethereum versions)
  root?: string; // The root of the state trie (optional, pre Byzantium fork)
};

type LogEntry = {
  address: string; // Address of the contract that generated this log
  topics: string[]; // Array of 32 byte topics.
  data: string; // Data for the log
  blockNumber: string; // The block number from which this log was generated (hex string, optional)
  transactionHash: string; // Hash of the transaction this log was created from (optional)
  transactionIndex: string; // Transaction index position in the block (optional)
  blockHash: string; // The block hash containing this log (optional)
  logIndex: string; // Index position in the log array of the block (optional)
  removed: boolean; // True if the log was reverted due to a chain reorganization (optional)
};

type EthereumRequestTransaction = {
  // Standard transaction fields
  from?: string; // 20-byte address
  to?: string; // 20-byte address (null for contract creation)
  gas?: string; // Gas limit as hex string
  gasPrice?: string; // Gas price in wei as hex string
  maxFeePerGas?: string; // EIP-1559 max fee per gas as hex string
  maxPriorityFeePerGas?: string; // EIP-1559 max priority fee per gas as hex string
  value?: string; // Value in wei as hex string
  data?: string; // Contract bytecode or encoded function call data

  // Legacy transaction fields
  nonce?: string; // Transaction nonce as hex string

  // EIP-1559 transaction fields
  type?: string; // Transaction type (0x0 for legacy, 0x2 for EIP-1559)

  // Access list for EIP-2930
  accessList?: Array<{
    address: string; // 20-byte address
    storageKeys: string[]; // Array of 32-byte storage keys
  }>;

  // Chain ID for replay protection
  chainId?: string; // Chain ID as hex string

  // Signature fields
  v?: string; // Recovery ID as hex string
  r?: string; // First 32 bytes of signature as hex string
  s?: string; // Last 32 bytes of signature as hex string
};

type EthereumResponseTransaction = {
  blockHash: string;
  blockNumber: string; // Hex string
  chainId: string;
  from: string;
  gas: string; // Hex string
  gasPrice?: string; // Gas price in wei as hex string
  maxFeePerGas?: string; // EIP-1559 max fee per gas as hex string
  maxPriorityFeePerGas?: string; // EIP-1559 max priority fee per gas as hex string
  hash: string;
  input: string;
  nonce: string; // Hex string
  to: string;
  type: string;
  transactionIndex: string; // Hex string
  value: string; // Hex string
  v: string; // Hex string
  r: string;
  s: string;
  accessList?: Array<{
    address: string; // 20-byte address
    storageKeys: string[]; // Array of 32-byte storage keys
  }>;
};

// ethers magic default
const DEFAULT_MAX_PRIORITY_FEE_PER_GAS = BigNumber.from("1500000000");

// every ethers error contains message reason code
// in our codebase we look only at message and code
export class Ethers5LikeError extends Error {
  constructor(
    readonly code: ethers.errors,
    readonly url: string,
    readonly method: string,
    message: string
  ) {
    super(message);
  }
}

// note to @Robert it will be important then when we switch to ethers v6 our provider will still throw ethers 5.7 error
// this was taken from json-rpc-provider.ts in ethers 5.7 version
export function getEthers5ErrorCode(msg: string): ethers.errors {
  if (
    /user denied|user rejected|denied signing|denied transaction|rejected (transaction|request|signing)/i.test(
      msg
    )
  ) {
    return ethers.errors.ACTION_REJECTED;
  }

  if (/insufficient funds|base fee exceeds gas limit/i.test(msg)) {
    return ethers.errors.INSUFFICIENT_FUNDS;
  }
  if (/nonce (is )?too low/i.test(msg)) {
    return ethers.errors.NONCE_EXPIRED;
  }
  if (/replacement transaction underpriced|transaction gas price.*too low/i.test(msg)) {
    return ethers.errors.REPLACEMENT_UNDERPRICED;
  }
  if (/only replay-protected/i.test(msg)) {
    return ethers.errors.UNSUPPORTED_OPERATION;
  }
  if (/gas required exceeds allowance|always failing transaction/i.test(msg)) {
    return ethers.errors.UNPREDICTABLE_GAS_LIMIT;
  }
  if (/execution reverted|revert(ed)?/i.test(msg)) {
    return ethers.errors.CALL_EXCEPTION;
  }
  if (/not implemented/i.test(msg)) {
    return ethers.errors.NOT_IMPLEMENTED;
  }
  if (/unsupported operation|not supported/i.test(msg)) {
    return ethers.errors.UNSUPPORTED_OPERATION;
  }
  if (/(timeout|timed out|time out)/i.test(msg)) {
    return ethers.errors.TIMEOUT;
  }
  if (
    /network error|could not detect network|failed to fetch|gateway timeout|(?:^|\b)(502|503|504)(?:\b|$)/i.test(
      msg
    )
  ) {
    return ethers.errors.NETWORK_ERROR;
  }
  if (/server error/i.test(msg)) {
    return ethers.errors.SERVER_ERROR;
  }

  return ethers.errors.SERVER_ERROR;
}

// spec https://ethereum.github.io/execution-apis/api-documentation/
export class RedstoneProvider {
  private id: number = 0;

  constructor(
    private readonly httpClient: HttpClient,
    public readonly url: string
  ) {}

  private static stripLeadingZerosFromValue<T>(value: T): T {
    if (typeof value === "string" && value.length > 3) {
      return stripLeadingZeros(value) as T;
    }

    if (Array.isArray(value)) {
      const result = [];
      for (const item of value) {
        result.push(RedstoneProvider.stripLeadingZerosFromValue(item));
      }
      return result as T;
    }

    if (value && typeof value === "object") {
      const result: Record<string, unknown> = {};
      for (const [key, val] of Object.entries(value)) {
        result[key] = RedstoneProvider.stripLeadingZerosFromValue(val);
      }
      return result as T;
    }

    return value;
  }

  async send<T>(method: string, params: unknown[], config: AxiosRequestConfig = {}): Promise<T> {
    const newId = this.id + (1 % Number.MAX_SAFE_INTEGER);

    const message: EthereumRpcRequest = {
      jsonrpc: "2.0",
      method: method,
      params: params,
      id: newId,
    };
    this.id = newId;

    const sanitizedMessage = RedstoneProvider.stripLeadingZerosFromValue(message);

    const response = await this.httpClient.post<EthereumRpcResponse<T>>(
      this.url,
      sanitizedMessage,
      config
    );

    if (RedstoneCommon.isDefined(response.data.error)) {
      throw new Ethers5LikeError(
        getEthers5ErrorCode(response.data.error.message),
        this.url,
        "send",
        response.data.error.message
      );
    }

    if (response.data.id !== newId) {
      throw new Ethers5LikeError(
        ethers.errors.SERVER_ERROR,
        this.url,
        "send",
        `Invalid id received expected=${newId} given=${response.data.id}`
      );
    }

    return response.data.result;
  }
}

export class RedstoneEthers5Provider implements ethers.providers.Provider {
  _isProvider: boolean = true;
  private readonly url: string;

  constructor(
    private readonly rpc: RedstoneProvider,
    private readonly network: { name: string; chainId: number },
    private readonly poolingInterval: number = 500,
    private readonly waitForTransactionTimeout: number = 60_000
  ) {
    this.url = this.rpc.url;
  }

  getNetwork(): Promise<ethers.providers.Network> {
    return Promise.resolve(this.network);
  }

  async getBlockNumber(): Promise<number> {
    const blockNumberInHex = await this.rpc.send<string>("eth_blockNumber", []);
    return Number.parseInt(blockNumberInHex, 16);
  }

  async getGasPrice(): Promise<ethers.BigNumber> {
    const gasPriceInHex = await this.rpc.send("eth_gasPrice", []);
    return BigNumber.from(gasPriceInHex);
  }

  // this is very naive (and stupid) implementation, we have better in TxDelivery
  // however my objective was to be aligned with ethers (because battle tested)
  async getFeeData(): Promise<ethers.providers.FeeData> {
    const [block, gasPrice] = await Promise.all([
      this.rpc.send<ethers.providers.Block>("eth_getBlockByNumber", ["latest", false]),
      this.getGasPrice(),
    ]);

    // legacy transaction
    if (!RedstoneCommon.isDefined(block.baseFeePerGas)) {
      return {
        gasPrice,
        lastBaseFeePerGas: null,
        maxFeePerGas: null,
        maxPriorityFeePerGas: null,
      };
    } else {
      const baseBaseFeePerGas = BigNumber.from(block.baseFeePerGas);
      // EIP-1559
      return {
        gasPrice,
        lastBaseFeePerGas: baseBaseFeePerGas,
        maxFeePerGas: baseBaseFeePerGas.mul(2).add(DEFAULT_MAX_PRIORITY_FEE_PER_GAS),
        maxPriorityFeePerGas: DEFAULT_MAX_PRIORITY_FEE_PER_GAS,
      };
    }
  }

  async getBalance(
    addressOrName: string | Promise<string>,
    blockTag?: ethers.providers.BlockTag | Promise<ethers.providers.BlockTag>
  ): Promise<ethers.BigNumber> {
    const balance = await this.rpc.send<string>("eth_getBalance", [
      await resolveAddress(addressOrName),
      await resolveBlockTag(blockTag),
    ]);
    return BigNumber.from(balance);
  }

  async getTransactionCount(
    addressOrName: string | Promise<string>,
    blockTag?: ethers.providers.BlockTag | Promise<ethers.providers.BlockTag>
  ): Promise<number> {
    const nonceHex = await this.rpc.send<string>("eth_getTransactionCount", [
      await resolveAddress(addressOrName),
      await resolveBlockTag(blockTag),
    ]);
    return Number.parseInt(nonceHex, 16);
  }

  async getCode(
    addressOrName: string | Promise<string>,
    blockTag?: ethers.providers.BlockTag | Promise<ethers.providers.BlockTag>
  ): Promise<string> {
    return await this.rpc.send<string>("eth_getCode", [
      await resolveAddress(addressOrName),
      await resolveBlockTag(blockTag),
    ]);
  }

  async getStorageAt(
    addressOrName: string | Promise<string>,
    position: ethers.BigNumberish | Promise<ethers.BigNumberish>,
    blockTag?: ethers.providers.BlockTag | Promise<ethers.providers.BlockTag>
  ): Promise<string> {
    const positionAsBigNumber = BigNumber.from(position);

    return await this.rpc.send<string>("eth_getStorageAt", [
      await resolveAddress(addressOrName),
      hexZeroPad(positionAsBigNumber.toHexString(), 32),
      await resolveBlockTag(blockTag),
    ]);
  }

  async call(
    transaction: ethers.utils.Deferrable<ethers.providers.TransactionRequest>,
    blockTag?: ethers.providers.BlockTag | Promise<ethers.providers.BlockTag>
  ): Promise<string> {
    // Resolve required fields first to fail fast, then resolve optional fields in parallel
    const [to, data] = await Promise.all([transaction.to, transaction.data]);

    if (!RedstoneCommon.isDefined(to)) {
      throw new Ethers5LikeError(
        ethers.errors.UNEXPECTED_ARGUMENT,
        this.url,
        "call",
        "Missing 'to' field in call request"
      );
    }

    // Resolve all fields in parallel for maximum efficiency on purpose omit of using resolveProperties
    const [
      resolvedTo,
      resolvedFrom,
      resolvedValue,
      resolvedGasLimit,
      resolvedGasPrice,
      resolvedMaxFeePerGas,
      resolvedMaxPriorityFeePerGas,
      resolvedBlockTag,
    ] = await Promise.all([
      resolveAddress(to),
      resolveAddress(await transaction.from),
      transaction.value,
      transaction.gasLimit,
      transaction.gasPrice,
      transaction.maxFeePerGas,
      transaction.maxPriorityFeePerGas,
      resolveBlockTag(blockTag),
    ]);

    const callParams: Partial<EthereumRequestTransaction> = {
      to: resolvedTo,
      data: bytesLikeToHex(data),
      from: resolvedFrom,
      value: bigNumberishToHex(resolvedValue),
      gas: bigNumberishToHex(resolvedGasLimit),
      gasPrice: bigNumberishToHex(resolvedGasPrice),
      maxFeePerGas: bigNumberishToHex(resolvedMaxFeePerGas),
      maxPriorityFeePerGas: bigNumberishToHex(resolvedMaxPriorityFeePerGas),
    };

    return await this.rpc.send<string>("eth_call", [callParams, resolvedBlockTag]);
  }

  async estimateGas(
    transaction: ethers.utils.Deferrable<ethers.providers.TransactionRequest>
  ): Promise<ethers.BigNumber> {
    // Resolve required fields first to fail fast
    const [to, data] = await Promise.all([transaction.to, transaction.data]);

    if (!RedstoneCommon.isDefined(to)) {
      throw new Ethers5LikeError(
        ethers.errors.UNEXPECTED_ARGUMENT,
        this.url,
        "estitmateGas",
        "Missing 'to' field in call request"
      );
    }

    // Resolve all fields in parallel for maximum efficiency on purpose omit of using resolveProperties
    const [
      resolvedTo,
      resolvedFrom,
      resolvedValue,
      resolvedGasLimit,
      resolvedGasPrice,
      resolvedMaxFeePerGas,
      resolvedMaxPriorityFeePerGas,
    ] = await Promise.all([
      resolveAddress(to),
      resolveAddress(await transaction.from),
      transaction.value,
      transaction.gasLimit,
      transaction.gasPrice,
      transaction.maxFeePerGas,
      transaction.maxPriorityFeePerGas,
    ]);

    const callParams: Partial<EthereumRequestTransaction> = {
      to: resolvedTo,
      data: bytesLikeToHex(data),
      from: resolvedFrom,
      value: bigNumberishToHex(resolvedValue),
      gas: bigNumberishToHex(resolvedGasLimit),
      gasPrice: bigNumberishToHex(resolvedGasPrice),
      maxFeePerGas: bigNumberishToHex(resolvedMaxFeePerGas),
      maxPriorityFeePerGas: bigNumberishToHex(resolvedMaxPriorityFeePerGas),
    };

    const gasHex = await this.rpc.send<string>("eth_estimateGas", [callParams]);
    return BigNumber.from(gasHex);
  }

  async getTransaction(transactionHash: string): Promise<ethers.providers.TransactionResponse> {
    const [tx, blockNumber] = await Promise.all([
      this.rpc.send<EthereumResponseTransaction>("eth_getTransactionByHash", [transactionHash]),
      this.getBlockNumber(),
    ]);

    if (!RedstoneCommon.isDefined(tx)) {
      // it hurts but this is how ethers is rolling
      return null as unknown as ethers.providers.TransactionResponse;
    }

    const response = this.toTransactionResponse(tx, blockNumber, transactionHash);

    return response;
  }

  async getTransactionReceipt(
    transactionHash: string
  ): Promise<ethers.providers.TransactionReceipt> {
    const [receipt, blockNumber] = await Promise.all([
      this.rpc.send<TransactionReceipt>("eth_getTransactionReceipt", [transactionHash]),
      this.getBlockNumber(),
    ]);

    if (!RedstoneCommon.isDefined(receipt)) {
      // it hurts but this is how ethers is rolling
      return null as unknown as ethers.providers.TransactionReceipt;
    }

    const receiptBlockNumber = Number.parseInt(receipt.blockNumber, 16);
    const response: ethers.providers.TransactionReceipt = {
      // @ts-expect-error this is null if this is contract creation ethers types are lying again
      to: RedstoneCommon.isDefined(receipt.to) ? getAddress(receipt.to) : receipt.to,
      from: getAddress(receipt.from),
      // @ts-expect-error this is null if this is contract creation ethers types are lying again
      contractAddress: RedstoneCommon.isDefined(receipt.contractAddress)
        ? getAddress(receipt.contractAddress)
        : receipt.contractAddress,
      transactionIndex: Number.parseInt(receipt.transactionIndex, 16),
      gasUsed: BigNumber.from(receipt.gasUsed),
      logsBloom: receipt.logsBloom,
      blockHash: receipt.blockHash,
      transactionHash: receipt.transactionHash,
      blockNumber: receiptBlockNumber,
      confirmations: blockNumber - receiptBlockNumber + 1,
      cumulativeGasUsed: BigNumber.from(receipt.cumulativeGasUsed),
      effectiveGasPrice: BigNumber.from(receipt.effectiveGasPrice),
      byzantium: RedstoneCommon.isDefined(receipt.status),
      status: RedstoneCommon.isDefined(receipt.status)
        ? Number.parseInt(receipt.status, 16)
        : receipt.status,
      // ethers defaults to 0
      type: RedstoneCommon.isDefined(receipt.type) ? Number.parseInt(receipt.type, 16) : 0,
      logs: receipt.logs.map((log) => ({
        transactionIndex: Number.parseInt(log.transactionIndex, 16),
        logIndex: Number.parseInt(log.logIndex, 16),
        blockHash: log.blockHash,
        blockNumber: receiptBlockNumber,
        removed: log.removed,
        address: getAddress(log.address),
        data: log.data,
        transactionHash: log.transactionHash,
        topics: log.topics,
      })),
    };

    if (RedstoneCommon.isDefined(receipt.root)) {
      response.root = receipt.root;
    }

    return response;
  }

  async getLogs(filter: ethers.providers.Filter): Promise<Array<ethers.providers.Log>> {
    const parsedFilter: {
      fromBlock?: string;
      toBlock?: string;
      address?: string;
      topics?: ethers.providers.Filter["topics"];
    } = {};

    if (RedstoneCommon.isDefined(filter.address)) {
      parsedFilter.address = filter.address;
    }
    if (RedstoneCommon.isDefined(filter.topics)) {
      parsedFilter.topics = filter.topics;
    }
    if (RedstoneCommon.isDefined(filter.toBlock)) {
      parsedFilter.toBlock =
        typeof filter.toBlock === "number" ? "0x" + filter.toBlock.toString(16) : filter.toBlock;
    }
    if (RedstoneCommon.isDefined(filter.fromBlock)) {
      parsedFilter.fromBlock =
        typeof filter.fromBlock === "number"
          ? "0x" + filter.fromBlock.toString(16)
          : filter.fromBlock;
    }

    const logs = await this.rpc.send<LogEntry[]>("eth_getLogs", [parsedFilter]);

    return logs.map((log) => ({
      transactionIndex: Number.parseInt(log.transactionIndex, 16),
      logIndex: Number.parseInt(log.logIndex, 16),
      blockHash: log.blockHash,
      blockNumber: Number.parseInt(log.blockNumber, 16),
      removed: log.removed,
      address: getAddress(log.address),
      data: log.data,
      transactionHash: log.transactionHash,
      topics: log.topics,
    }));
  }

  getBlock(
    blockHashOrBlockTag:
      | ethers.providers.BlockTag
      | string
      | Promise<ethers.providers.BlockTag | string>
  ): Promise<ethers.providers.Block> {
    return this._getBlock(blockHashOrBlockTag, false) as Promise<ethers.providers.Block>;
  }

  getBlockWithTransactions(
    blockHashOrBlockTag: ethers.providers.BlockTag | string | Promise<ethers.providers.BlockTag>
  ): Promise<BlockWithTransactions> {
    return this._getBlock(blockHashOrBlockTag, true) as Promise<BlockWithTransactions>;
  }

  private async _getBlock(
    blockHashOrBlockTag:
      | ethers.providers.BlockTag
      | string
      | Promise<ethers.providers.BlockTag | string>,
    withTransactions: boolean
  ): Promise<ethers.providers.Block | BlockWithTransactions> {
    const resolved = await blockHashOrBlockTag;

    if (typeof resolved === "string" && resolved.startsWith("0x") && resolved.length === 66) {
      const [result, currentBlockNumber] = await Promise.all([
        await this.rpc.send<EthereumBlock>("eth_getBlockByHash", [resolved, withTransactions]),
        this.getBlockNumber(),
      ]);
      if (!RedstoneCommon.isDefined(result)) {
        // i know ethers ...
        return null as unknown as ethers.providers.Block | BlockWithTransactions;
      }

      const block = this.parseToEthersBlock(result, withTransactions, currentBlockNumber);

      return block;
    } else {
      // It's a block tag or number
      const blockNumber = await resolveBlockTag(blockHashOrBlockTag);
      const [result, currentBlockNumber] = await Promise.all([
        await this.rpc.send<EthereumBlock>("eth_getBlockByNumber", [blockNumber, withTransactions]),
        this.getBlockNumber(),
      ]);

      if (!RedstoneCommon.isDefined(result)) {
        // i know ethers ...
        return null as unknown as ethers.providers.Block | BlockWithTransactions;
      }

      return this.parseToEthersBlock(result, withTransactions, currentBlockNumber);
    }
  }

  async sendTransaction(
    signedTransaction: string | Promise<string>
  ): Promise<ethers.providers.TransactionResponse> {
    const resolvedTx = await signedTransaction;

    const txHash = await this.rpc.send<string>("eth_sendRawTransaction", [resolvedTx]);

    const error = new Ethers5LikeError(
      ethers.errors.TIMEOUT,
      this.url,
      "sendTransaction",
      `Timeout waiting for transaction hash=${txHash} timeout=${this.waitForTransactionTimeout}`
    );

    return await RedstoneCommon.timeoutWithCustomError(
      this._waitForTransaction(txHash),
      this.waitForTransactionTimeout,
      error
    );
  }

  async _waitForTransaction(txHash: string): Promise<ethers.providers.TransactionResponse> {
    const start = performance.now();
    for (;;) {
      const transaction = await this.getTransaction(txHash);

      if (RedstoneCommon.isDefined(transaction)) {
        return transaction;
      }

      await RedstoneCommon.sleep(this.poolingInterval);

      if (performance.now() - start > this.waitForTransactionTimeout) {
        throw new Ethers5LikeError(
          ethers.errors.TIMEOUT,
          this.url,
          "sendTransaction",
          `Timeout waiting for transaction hash=${txHash} timeout=${this.waitForTransactionTimeout}`
        );
      }
    }
  }

  waitForTransaction(
    transactionHash: string,
    confirmations: number = 1,
    timeout: number = this.waitForTransactionTimeout
  ): Promise<ethers.providers.TransactionReceipt> {
    const error = new Ethers5LikeError(
      ethers.errors.TIMEOUT,
      this.url,
      "waitForTransaction",
      `Timeout waiting for transaction receipt hash=${transactionHash} timeout=${timeout}`
    );
    return RedstoneCommon.timeoutWithCustomError(
      this._waitForReceipt(transactionHash, confirmations, timeout),
      timeout,
      error
    );
  }

  async _waitForReceipt(
    transactionHash: string,
    confirmations: number,
    timeout: number
  ): Promise<ethers.providers.TransactionReceipt> {
    const start = performance.now();
    for (;;) {
      const transactionReceipt = await this.getTransactionReceipt(transactionHash);

      if (
        RedstoneCommon.isDefined(transactionReceipt) &&
        transactionReceipt.confirmations >= confirmations
      ) {
        return transactionReceipt;
      }

      await RedstoneCommon.sleep(this.poolingInterval);

      if (performance.now() - start > timeout) {
        throw new Ethers5LikeError(
          ethers.errors.TIMEOUT,
          this.url,
          "waitForTransaction",
          `Timeout waiting for transaction receipt hash=${transactionHash} timeout=${timeout}`
        );
      }
    }
  }

  parseToEthersBlock(
    block: EthereumBlock,
    withTransactions: boolean,
    currentBlockNumber: number
  ): ethers.providers.Block | BlockWithTransactions {
    let transactions: string[] | TransactionResponse[] = block.transactions;
    if (withTransactions) {
      transactions = (block.transactions as unknown as EthereumResponseTransaction[]).map((tx) =>
        this.toTransactionResponse(tx, currentBlockNumber, tx.hash)
      );
    }
    const response: ethers.providers.Block | BlockWithTransactions = {
      transactions: transactions as string[],
      hash: block.hash,
      parentHash: block.parentHash,
      number: Number.parseInt(block.number, 16),
      timestamp: Number.parseInt(block.timestamp, 16),
      nonce: block.nonce,
      difficulty: Number.parseInt(block.difficulty, 16),
      _difficulty: BigNumber.from(block.difficulty),
      gasLimit: BigNumber.from(block.gasLimit),
      gasUsed: BigNumber.from(block.gasUsed),
      miner: getAddress(block.miner),
      extraData: block.extraData,
    };
    if (RedstoneCommon.isDefined(block.baseFeePerGas)) {
      response.baseFeePerGas = BigNumber.from(block.baseFeePerGas);
    }
    return response;
  }

  toTransactionResponse(
    tx: EthereumResponseTransaction,
    currentBlockNumber: number,
    transactionHash: string
  ) {
    const txBlockNumber = Number.parseInt(tx.blockNumber, 16);
    const confirmations = currentBlockNumber - txBlockNumber + 1;

    const response: ethers.providers.TransactionResponse = {
      hash: transactionHash,
      nonce: Number.parseInt(tx.nonce, 16),
      gasLimit: BigNumber.from(tx.gas),
      data: tx.input,
      value: BigNumber.from(tx.value),
      chainId: Number.parseInt(tx.chainId, 16),
      // this is inefficient to call this getAddress, but we want to stay compatible
      from: getAddress(tx.from),
      to: getAddress(tx.to),
      r: hexZeroPad(tx.r, 32),
      s: hexZeroPad(tx.s, 32),
      v: Number.parseInt(tx.v, 16),
      type: Number.parseInt(tx.type, 16),
      accessList: RedstoneCommon.isDefined(tx.accessList) ? tx.accessList : [],

      gasPrice: RedstoneCommon.isDefined(tx.gasPrice) ? BigNumber.from(tx.gasPrice) : undefined,
      maxPriorityFeePerGas: RedstoneCommon.isDefined(tx.maxPriorityFeePerGas)
        ? BigNumber.from(tx.maxPriorityFeePerGas)
        : undefined,
      maxFeePerGas: RedstoneCommon.isDefined(tx.maxFeePerGas)
        ? BigNumber.from(tx.maxFeePerGas)
        : undefined,

      // ethers types this as undefined but in reallity returns null
      blockHash: tx.blockHash === "0x00000000000000000000000000000000" ? undefined : tx.blockHash,
      blockNumber: txBlockNumber,

      // @ts-expect-error - this field is returned by ethers but not part of TransactionResponse type
      transactionIndex: Number.parseInt(tx.transactionIndex, 16),

      // computed fileds
      creates: !RedstoneCommon.isDefined(tx.to) ? getContractAddress(tx) : null,
      confirmations,
      wait: (confirmations?: number) =>
        this.waitForTransaction(transactionHash, confirmations, this.waitForTransactionTimeout),
    };
    return response;
  }

  // ENS is not supported
  async resolveName(_name: string | Promise<string>): Promise<null | string> {
    const awaitedName = await _name;

    if (awaitedName.startsWith("0x") && awaitedName.length === 42) {
      return awaitedName;
    }

    throw new Error(
      "ENS is not supported by RedstoneProvider - could not execute resolveName method. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }

  lookupAddress(_address: string | Promise<string>): Promise<null | string> {
    throw new Error(
      "Method 'lookupAddress' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }

  // all events related methods are not supported
  on(
    _eventName: ethers.providers.EventType,
    _listener: ethers.providers.Listener
  ): ethers.providers.Provider {
    throw new Error(
      "Method 'on' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }
  once(
    _eventName: ethers.providers.EventType,
    _listener: ethers.providers.Listener
  ): ethers.providers.Provider {
    throw new Error(
      "Method 'once' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }
  emit(_eventName: ethers.providers.EventType, ..._args: Array<unknown>): boolean {
    throw new Error(
      "Method 'emit' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }
  listenerCount(_eventName?: ethers.providers.EventType): number {
    throw new Error(
      "Method 'listenerCount' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }
  listeners(_eventName?: ethers.providers.EventType): Array<ethers.providers.Listener> {
    throw new Error(
      "Method 'listeners' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }
  off(
    _eventName: ethers.providers.EventType,
    _listener?: ethers.providers.Listener
  ): ethers.providers.Provider {
    throw new Error(
      "Method 'off' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }
  removeAllListeners(_eventName?: ethers.providers.EventType): ethers.providers.Provider {
    throw new Error(
      "Method 'removeAllListeners' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }
  addListener(
    _eventName: ethers.providers.EventType,
    _listener: ethers.providers.Listener
  ): ethers.providers.Provider {
    throw new Error(
      "Method 'addListener' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }
  removeListener(
    _eventName: ethers.providers.EventType,
    _listener: ethers.providers.Listener
  ): ethers.providers.Provider {
    throw new Error(
      "Method 'removeListener' not supported by RedstoneProvider. Choose diffrent provider like StaticJsonRpcProvider"
    );
  }
}

function stripLeadingZeros(hexString: string): string {
  if (!hexString.startsWith("0x")) {
    return hexString;
  }

  return hexValue(hexString);
}

async function resolveBlockTag(
  blockTag?: ethers.providers.BlockTag | Promise<ethers.providers.BlockTag>
) {
  if (!RedstoneCommon.isDefined(blockTag)) {
    return "latest";
  }
  const blockTagAwaited = await blockTag;
  if (typeof blockTagAwaited === "string") {
    return blockTagAwaited;
  }
  return "0x" + blockTagAwaited.toString(16);
}

async function resolveAddress(address: string | Promise<string> | undefined) {
  if (!RedstoneCommon.isDefined(address)) {
    return address;
  }
  return (await address).toLowerCase();
}

function bigNumberishToHex(bigNumberish: BigNumberish | undefined | null): string | undefined {
  if (!RedstoneCommon.isDefined(bigNumberish)) {
    return undefined;
  }
  if (typeof bigNumberish === "string" && bigNumberish.startsWith("0x")) {
    return bigNumberish;
  }
  if (typeof bigNumberish === "number") {
    return "0x" + bigNumberish.toString(16);
  }
  return BigNumber.from(bigNumberish).toHexString();
}

function bytesLikeToHex(bytesLike: BytesLike | undefined): string | undefined {
  if (!RedstoneCommon.isDefined(bytesLike)) {
    return undefined;
  }
  if (typeof bytesLike === "string" && bytesLike.startsWith("0x")) {
    return bytesLike;
  }

  return hexlify(bytesLike);
}
