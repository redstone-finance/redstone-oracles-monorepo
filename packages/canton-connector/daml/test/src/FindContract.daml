module FindContract (
    findOneAdapter
    , findAnyAdapter
    , findOnePriceFeed
    , findAnyPriceFeed
) where

import Daml.Script
import DA.Foldable (forA_)
import DA.List as L
import DA.Optional (fromSome)
import IRedStoneAdapter
import IRedStonePriceFeed
import RedStoneTypes

findContract checkIsUnique test party contracts = do
  let filtered = filter (\(_, view) -> test view) $ map (\(cid, view) -> (cid, fromSome view)) contracts

  forA_ filtered
    $ \ (cid, view)
      -> do debug $ "Contract ID: " <> show cid
            debug $ "Contract data: " <> show view
          
  assertMsg ("Contract length is " <> show (L.length contracts)) $  not checkIsUnique || L.length contracts == 1
      
  let (contractCid, _) = L.head filtered

  return contractCid

findAdapter: Bool -> Text -> Party ->  Script (ContractId IRedStoneAdapter)
findAdapter checkIsUnique adapterId party = do
    contracts <- queryInterface @IRedStoneAdapter party 
    
    findContract checkIsUnique (\view -> view.adapterId == adapterId) party contracts

findPriceFeed: Bool -> Text -> RedStoneFeedId -> Party -> Script (ContractId IRedStonePriceFeed)
findPriceFeed checkIsUnique adapterId feedId party = do
    contracts <- queryInterface @IRedStonePriceFeed party 
    
    findContract checkIsUnique (\view -> view.adapterId == adapterId && view.feedId == feedId) party contracts

findOneAdapter = findAdapter True 
findAnyAdapter = findAdapter False 

findOnePriceFeed = findPriceFeed True

findAnyPriceFeed = findPriceFeed False
