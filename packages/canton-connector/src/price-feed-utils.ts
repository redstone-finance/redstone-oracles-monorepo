import { LastRoundDetails } from "@redstone-finance/sdk";
import _ from "lodash";
import { CreatedEvent } from "./_autogenerated";
import { ContractFilter } from "./CantonClient";
import { convertDecimalValue, getArrayifiedFeedId } from "./conversions";

export const IPRICE_FEED_ENTRY_TEMPLATE_NAME = `IRedStonePricePill:IRedStonePricePill`;
export const READ_DATA_CHOICE = "ReadData";
export const READ_FEED_ID_CHOICE = "ReadFeedId";
export const READ_DESCRIPTION_CHOICE = "ReadDescription";
export const ARCHIVE = "Archive";

export type PriceData = {
  value: string;
  timestamp: string;
  writeTimestamp: string;
};

export function parsePriceData(result: PriceData): LastRoundDetails {
  return {
    lastDataPackageTimestampMS: Number.parseInt(result.timestamp),
    lastBlockTimestampMS: Number.parseInt(result.writeTimestamp),
    lastValue: convertDecimalValue(result.value),
  };
}

export function findNewestContract(events: CreatedEvent[]): CreatedEvent | undefined {
  if (!events.length) {
    return undefined;
  }

  return _.maxBy(events, (e) =>
    Number((e.createArgument as { priceData?: PriceData } | undefined)?.priceData?.timestamp ?? 0)
  );
}

export function createFeedIdFilter(arrayifiedFeedIds: number[][]): ContractFilter {
  return ((createArgument: { feedId: string[] }) =>
    arrayifiedFeedIds.some((arrayified) =>
      _.isEqual(createArgument.feedId.map(Number), arrayified)
    )) as ContractFilter;
}

export function createStalenessFilter(keepFresh: boolean = true): ContractFilter {
  return ((createArgument: { priceData: { writeTimestamp: string }; stalenessMs: string }) => {
    const currentTime = Date.now();
    const writeTimestamp = Number(createArgument.priceData.writeTimestamp);
    const stalenessMs = Number(createArgument.stalenessMs);
    const isFresh = currentTime - writeTimestamp <= stalenessMs;

    return keepFresh === isFresh;
  }) as ContractFilter;
}

export function groupEventsByFeedId(
  events: CreatedEvent[],
  feedIds: string[],
  arrayifiedFeedIds: Map<string, number[]>
): Record<string, CreatedEvent[]> {
  return _.groupBy(events, (event) =>
    feedIds.find((feedId) =>
      _.isEqual(
        (event.createArgument as { feedId: string[] } | undefined)?.feedId.map(Number),
        arrayifiedFeedIds.get(feedId)
      )
    )
  );
}

export function buildArrayifiedFeedIds(feedIds: string[]): Map<string, number[]> {
  return new Map(feedIds.map((feedId) => [feedId, getArrayifiedFeedId(feedId)]));
}
