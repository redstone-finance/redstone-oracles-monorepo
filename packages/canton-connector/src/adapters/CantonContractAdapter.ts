import { loggerFactory, RedstoneCommon } from "@redstone-finance/utils";
import { ApiError } from "../_autogenerated";
import { CantonClient, ContractFilter } from "../CantonClient";
import { ActiveContractData, isContractNotFoundError } from "../utils";

const RETRY_CONFIG: Omit<RedstoneCommon.RetryConfig, "fn"> = {
  maxRetries: 3,
  waitBetweenMs: 100,
  backOff: {
    backOffBase: 1.5,
  },
};

export type ChoiceInput<Arg extends object = object> = {
  choice: string;
  argument: Arg;
  contractId: string;
};

export abstract class CantonContractAdapter {
  protected readonly logger = loggerFactory("canton-contract-adapter");
  protected activeContractData?: ActiveContractData;

  protected constructor(
    protected readonly client: CantonClient,
    protected readonly interfaceId: string,
    protected readonly templateName: string
  ) {}

  async fetchContractData(offset?: number, client = this.client) {
    return await client.getActiveContractData(
      this.getInterfaceId(),
      this.getContractFilter(),
      offset
    );
  }

  protected getInterfaceId() {
    return `${this.interfaceId}:${this.templateName}`;
  }

  protected abstract getContractFilter(): ContractFilter;

  protected async exerciseChoice<Res, Arg extends object = object>(
    choice: string,
    argument: Arg,
    offset: number | undefined = undefined,
    addCurrentTime = false,
    client = this.client,
    disclosedContractData?: Required<ActiveContractData>[]
  ): Promise<Res> {
    this.activeContractData ??= await this.fetchContractData(offset, client);

    try {
      const results = await this.exerciseChoices<Res, Arg>(
        [{ choice, argument, contractId: this.activeContractData.contractId }],
        this.getInterfaceId(),
        addCurrentTime,
        client,
        disclosedContractData
      );

      const [result] = Object.values(results);
      if (!result) {
        throw new Error(`No result for choice ${choice}`);
      }

      return result;
    } catch (error) {
      if (isContractNotFoundError(error)) {
        this.activeContractData = undefined;
      }
      throw error;
    }
  }

  protected async exerciseChoices<Res, Arg extends object = object>(
    choices: ChoiceInput<Arg>[],
    interfaceId: string,
    addCurrentTime = false,
    client = this.client,
    disclosedContractData?: Required<ActiveContractData>[]
  ): Promise<Record<string, Res>> {
    const timestamp = new Date();

    const commands = choices.map(({ choice, argument, contractId }) => ({
      choice,
      contractId,
      templateId: interfaceId,
      choiceArgument: addCurrentTime
        ? { ...argument, currentTime: timestamp.toISOString() }
        : argument,
    }));

    try {
      return await RedstoneCommon.retry({
        ...RETRY_CONFIG,
        fn: async () =>
          await client.exerciseChoices<Arg, Res>(commands, timestamp, disclosedContractData),
      })();
    } catch (error) {
      const apiError = error as ApiError;
      this.logger.error(
        `${RedstoneCommon.stringify((apiError.body as { cause: unknown }).cause)} ${RedstoneCommon.stringifyError(error)}`
      );
      throw error;
    }
  }
}
