import { loggerFactory, RedstoneCommon } from "@redstone-finance/utils";
import { ApiError } from "../_autogenerated";
import { CantonClient, ContractFilter } from "../CantonClient";
import { ActiveContractData, isContractNotFoundError } from "../utils";

const RETRY_CONFIG: Omit<RedstoneCommon.RetryConfig, "fn"> = {
  maxRetries: 3,
  waitBetweenMs: 100,
  backOff: {
    backOffBase: 1.5,
  },
};

export type ChoiceInput<Arg extends object = object> = {
  choice: string;
  argument: Arg;
  contractId: string;
};

export abstract class CantonContractAdapter {
  protected readonly logger = loggerFactory("canton-contract-adapter");
  protected activeContractData?: ActiveContractData;

  protected constructor(
    protected readonly client: CantonClient,
    protected readonly interfaceId: string,
    protected readonly templateName: string
  ) {}

  async fetchContractData(offset?: number, client = this.client) {
    return await client.getActiveContractData(
      this.getInterfaceId(),
      this.getContractFilter(),
      offset
    );
  }

  protected getInterfaceId() {
    return `${this.interfaceId}:${this.templateName}`;
  }

  protected abstract getContractFilter(): ContractFilter;

  private static buildCommands<Arg extends object>(
    choices: ChoiceInput<Arg>[],
    interfaceId: string,
    timestamp: Date,
    addCurrentTime: boolean
  ) {
    return choices.map(({ choice, argument, contractId }) => ({
      choice,
      contractId,
      templateId: interfaceId,
      choiceArgument: addCurrentTime
        ? { ...argument, currentTime: timestamp.toISOString() }
        : argument,
    }));
  }

  private async withRetryAndLogging<T>(fn: () => Promise<T>): Promise<T> {
    try {
      return await RedstoneCommon.retry({ ...RETRY_CONFIG, fn })();
    } catch (error) {
      const apiError = error as ApiError;
      this.logger.error(
        `${RedstoneCommon.stringify((apiError.body as { cause: unknown }).cause)} ${RedstoneCommon.stringifyError(error)}`
      );
      throw error;
    }
  }

  private async withContractDataCaching<T>(
    offset: number | undefined,
    client: CantonClient,
    fn: (contractId: string) => Promise<T>
  ): Promise<T> {
    this.activeContractData ??= await this.fetchContractData(offset, client);

    try {
      return await fn(this.activeContractData.contractId);
    } catch (error) {
      if (isContractNotFoundError(error)) {
        this.activeContractData = undefined;
      }
      throw error;
    }
  }

  protected async exerciseChoice<Res, Arg extends object = object>(
    choice: string,
    argument: Arg,
    offset: number | undefined = undefined,
    addCurrentTime = false,
    client = this.client,
    disclosedContractData?: Required<ActiveContractData>[]
  ): Promise<Res> {
    return await this.withContractDataCaching(offset, client, async (contractId) => {
      const results = await this.exerciseChoices<Res, Arg>(
        [{ choice, argument, contractId }],
        this.getInterfaceId(),
        addCurrentTime,
        client,
        disclosedContractData
      );

      const [result] = Object.values(results);
      if (!result) {
        throw new Error(`No result for choice ${choice}`);
      }

      return result;
    });
  }

  protected async exerciseChoices<Res, Arg extends object = object>(
    choices: ChoiceInput<Arg>[],
    interfaceId: string,
    addCurrentTime = false,
    client = this.client,
    disclosedContractData?: Required<ActiveContractData>[]
  ): Promise<Record<string, Res>> {
    const timestamp = new Date();
    const commands = CantonContractAdapter.buildCommands(
      choices,
      interfaceId,
      timestamp,
      addCurrentTime
    );

    return await this.withRetryAndLogging(() =>
      client.exerciseChoices<Arg, Res>(commands, timestamp, disclosedContractData)
    );
  }

  protected async exerciseChoiceWithoutWaiting<Arg extends object = object>(
    choice: string,
    argument: Arg,
    offset: number | undefined = undefined,
    addCurrentTime = false,
    client = this.client,
    disclosedContractData?: Required<ActiveContractData>[]
  ) {
    return await this.withContractDataCaching(offset, client, (contractId) =>
      this.exerciseChoicesWithoutWaiting<Arg>(
        [{ choice, argument, contractId }],
        this.getInterfaceId(),
        addCurrentTime,
        client,
        disclosedContractData
      )
    );
  }

  protected async exerciseChoicesWithoutWaiting<Arg extends object = object>(
    choices: ChoiceInput<Arg>[],
    interfaceId: string,
    addCurrentTime = false,
    client = this.client,
    disclosedContractData?: Required<ActiveContractData>[]
  ) {
    const timestamp = new Date();
    const commands = CantonContractAdapter.buildCommands(
      choices,
      interfaceId,
      timestamp,
      addCurrentTime
    );

    return await this.withRetryAndLogging(() =>
      client.exerciseChoicesWithoutWaiting<Arg>(commands, timestamp, disclosedContractData)
    );
  }
}
