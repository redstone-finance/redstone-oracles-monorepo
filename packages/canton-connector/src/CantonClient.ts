import { loggerFactory, RedstoneCommon } from "@redstone-finance/utils";
import _ from "lodash";
import {
  DefaultService,
  DisclosedContract,
  JsCantonError,
  OpenAPI,
  TransactionFormat,
} from "./_autogenerated";
import type { ApiRequestOptions } from "./_autogenerated/core/ApiRequestOptions";
import { CantonNetwork } from "./CantonNetwork";
import * as AllDefs from "./contracts.json";
import {
  isCreatedEvent,
  isJsActiveContractEntry,
  isTransactionUpdate,
  makeActiveContractData,
  makeInterfaceFilterByParty,
  unwrapResponse,
} from "./utils";

export type ContractFilter = (createArgument: unknown) => boolean;

const DEFAULT_DELTA_OFFSET = 1000;
const LOCAL_USER = "redstone-canton-connector";

const RETRY_CONFIG: Omit<RedstoneCommon.RetryConfig, "fn"> = {
  maxRetries: 3,
  waitBetweenMs: 500,
  backOff: {
    backOffBase: 1.5,
  },
};

export class CantonClient {
  private readonly logger = loggerFactory("canton-client");

  Defs: (typeof AllDefs)["mainnet"];

  constructor(
    readonly partyId: string,
    private readonly baseUrl: string,
    network: CantonNetwork = "localnet",
    private readonly tokenProvider?: (options: ApiRequestOptions) => Promise<string>
  ) {
    this.Defs = AllDefs[network];
  }

  async getCurrentOffset() {
    return (await this.performRequest(DefaultService.getV2StateLedgerEnd, "getCurrentOffset"))
      .offset;
  }

  async getActiveContractData(interfaceId: string, filter?: ContractFilter, atOffset?: number) {
    const filtersByParty = makeInterfaceFilterByParty(interfaceId, this.partyId);
    const offset = atOffset ?? (await this.getCurrentOffset());
    const contracts = await this.performRequest(
      () =>
        DefaultService.postV2StateActiveContracts({
          filter: {
            filtersByParty,
          },
          activeAtOffset: offset,
          verbose: false,
        }),
      `postV2StateActiveContracts  ${RedstoneCommon.stringify(filtersByParty)}`
    );

    const adapters = contracts.filter(
      (contract) =>
        isJsActiveContractEntry(contract.contractEntry) &&
        (!filter || filter(contract.contractEntry.JsActiveContract.createdEvent.createArgument))
    );

    if (adapters.length === 1 && isJsActiveContractEntry(adapters[0].contractEntry)) {
      const jsActiveContract = adapters[0].contractEntry.JsActiveContract;
      return makeActiveContractData(jsActiveContract.createdEvent, jsActiveContract.synchronizerId);
    }

    throw new Error(`Unable to determine contract data: ${RedstoneCommon.stringify(contracts)}`);
  }

  async getCreateContractEvents(
    interfaceId: string,
    filter?: ContractFilter,
    atOffset?: number,
    deltaOffset = DEFAULT_DELTA_OFFSET
  ) {
    const filtersByParty = makeInterfaceFilterByParty(interfaceId, this.partyId);
    const offset = atOffset ?? (await this.getCurrentOffset());
    const contracts = await this.performRequest(
      () =>
        DefaultService.postV2Updates({
          beginExclusive: Math.max(0, offset - deltaOffset),
          verbose: false,
          updateFormat: {
            includeTransactions: {
              eventFormat: { filtersByParty, verbose: false },
              transactionShape: TransactionFormat.transactionShape.TRANSACTION_SHAPE_ACS_DELTA,
            },
          },
        }),
      `postV2Updates ${RedstoneCommon.stringify(filtersByParty)}`
    );

    const createdEvents = contracts
      .map((contract) =>
        isTransactionUpdate(contract.update) ? contract.update.Transaction : undefined
      )
      .filter(RedstoneCommon.isDefined)
      .map((transaction) => transaction.value.events?.filter((event) => isCreatedEvent(event)))
      .filter((list) => list?.length)
      .filter(RedstoneCommon.isDefined);

    return createdEvents
      .flat()
      .filter((createdEvent) => !filter || filter(createdEvent.CreatedEvent.createArgument))
      .map((createdEvent) => createdEvent.CreatedEvent);
  }

  async exerciseChoice<Arg extends object, Res = object>(
    command: { templateId: string; contractId: string; choice: string; choiceArgument: Arg },
    timestamp: Date,
    disclosedContracts?: DisclosedContract[]
  ) {
    const result = await this.performRequest(
      () =>
        // eslint-disable-next-line @typescript-eslint/no-deprecated -- needed and available for 3.4.9 for now
        DefaultService.postV2CommandsSubmitAndWaitForTransactionTree({
          commands: [
            {
              ExerciseCommand: command,
            },
          ],
          commandId: `${command.contractId}-${command.choice}-${timestamp.getTime()}`,
          actAs: [this.partyId],
          disclosedContracts,
          userId: !this.tokenProvider ? LOCAL_USER : undefined,
        }),
      `postV2CommandsSubmitAndWaitForTransactionTree ${RedstoneCommon.stringify({ ...command, choiceArgument: _.isEqual(command.choiceArgument, {}) ? undefined : "#ARGS#" })}`
    );

    const excerciseEvent = result.transactionTree.eventsById["0"];
    if ("ExercisedTreeEvent" in excerciseEvent) {
      if (excerciseEvent.ExercisedTreeEvent.value.consuming) {
        const createdEvent = result.transactionTree.eventsById["1"];

        if (RedstoneCommon.isDefined(createdEvent) && "CreatedTreeEvent" in createdEvent) {
          return makeActiveContractData(
            createdEvent.CreatedTreeEvent.value,
            result.transactionTree.synchronizerId
          ) as unknown as Res;
        }
      }

      return excerciseEvent.ExercisedTreeEvent.value.exerciseResult as Res;
    }

    throw new Error(RedstoneCommon.stringify(excerciseEvent));
  }

  private async performRequest<T>(
    promise: () => Promise<T | JsCantonError>,
    fnName = "performRequest"
  ) {
    OpenAPI.BASE = this.baseUrl;
    OpenAPI.TOKEN = this.tokenProvider;

    this.logger.info(`Calling ${fnName}`);

    return await RedstoneCommon.retry({
      ...RETRY_CONFIG,
      fn: () => unwrapResponse(promise()),
      logger: this.logger.log.bind(this),
      fnName,
    })();
  }
}
