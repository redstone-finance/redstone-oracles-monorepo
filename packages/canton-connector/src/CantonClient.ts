import { RedstoneCommon } from "@redstone-finance/utils";
import {
  DefaultService,
  DisclosedContract,
  JsCantonError,
  OpenAPI,
  TransactionFormat,
} from "./_autogenerated";
import type { ApiRequestOptions } from "./_autogenerated/core/ApiRequestOptions";
import * as AllDefs from "./contracts.json";
import {
  isCreatedEvent,
  isJsActiveContractEntry,
  isTransactionUpdate,
  makeActiveContractData,
  makeInterfaceFilterByParty,
  unwrapResponse,
} from "./utils";

export const CantonNetworks = ["devnet", "mainnet"] as const;
export type CantonNetwork = (typeof CantonNetworks)[number];
export type ContractFilter = (createArgument: unknown) => boolean;

export class CantonClient {
  Defs: (typeof AllDefs)["mainnet"];

  constructor(
    readonly partyId: string,
    private readonly baseUrl: string,
    private readonly tokenProvider: undefined | ((options: ApiRequestOptions) => Promise<string>),
    network: CantonNetwork = "devnet",
    private readonly userId: string | undefined = undefined
  ) {
    this.Defs = AllDefs[network];
  }

  async getCurrentOffset() {
    return (await this.performRequest(DefaultService.getV2StateLedgerEnd)).offset;
  }

  async getActiveContractData(interfaceId: string, filter?: ContractFilter, atOffset?: number) {
    const filtersByParty = makeInterfaceFilterByParty(interfaceId, this.partyId);
    const offset = atOffset ?? (await this.getCurrentOffset());
    const contracts = await this.performRequest(() =>
      DefaultService.postV2StateActiveContracts({
        filter: {
          filtersByParty,
        },
        activeAtOffset: offset,
        verbose: false,
      })
    );

    const adapters = contracts.filter(
      (contract) =>
        isJsActiveContractEntry(contract.contractEntry) &&
        (!filter || filter(contract.contractEntry.JsActiveContract.createdEvent.createArgument))
    );

    if (adapters.length === 1 && isJsActiveContractEntry(adapters[0].contractEntry)) {
      const jsActiveContract = adapters[0].contractEntry.JsActiveContract;
      return makeActiveContractData(jsActiveContract.createdEvent, jsActiveContract.synchronizerId);
    }

    throw new Error(`Unable to determine contract data: ${RedstoneCommon.stringify(contracts)}`);
  }

  async getCreateContractEvents(
    interfaceId: string,
    filter?: ContractFilter,
    atOffset?: number,
    deltaOffset = 1000
  ) {
    const filtersByParty = makeInterfaceFilterByParty(interfaceId, this.partyId);
    const offset = atOffset ?? (await this.getCurrentOffset());
    const contracts = await this.performRequest(() =>
      DefaultService.postV2Updates({
        beginExclusive: Math.max(0, offset - deltaOffset),
        verbose: false,
        updateFormat: {
          includeTransactions: {
            eventFormat: { filtersByParty, verbose: false },
            transactionShape: TransactionFormat.transactionShape.TRANSACTION_SHAPE_ACS_DELTA,
          },
        },
      })
    );

    const createdEvents = contracts
      .map((contract) =>
        isTransactionUpdate(contract.update) ? contract.update.Transaction : undefined
      )
      .filter(RedstoneCommon.isDefined)
      .map((transaction) => transaction.value.events?.filter((event) => isCreatedEvent(event)))
      .filter((list) => list?.length)
      .filter(RedstoneCommon.isDefined);

    return createdEvents
      .flat()
      .filter((createdEvent) => !filter || filter(createdEvent.CreatedEvent.createArgument))
      .map((createdEvent) => createdEvent.CreatedEvent);
  }

  async exerciseChoice<Arg extends object, Res = object>(
    command: { templateId: string; contractId: string; choice: string; choiceArgument: Arg },
    timestamp: Date,
    disclosedContracts?: DisclosedContract[]
  ) {
    const result = await this.performRequest(() =>
      // eslint-disable-next-line @typescript-eslint/no-deprecated -- needed and available for 3.4.9 for now
      DefaultService.postV2CommandsSubmitAndWaitForTransactionTree({
        commands: [
          {
            ExerciseCommand: command,
          },
        ],
        commandId: `${command.contractId}-${command.choice}-${timestamp.getTime()}`,
        actAs: [this.partyId],
        disclosedContracts,
        userId: this.userId,
      })
    );

    const excerciseEvent = result.transactionTree.eventsById["0"];
    if ("ExercisedTreeEvent" in excerciseEvent) {
      if (excerciseEvent.ExercisedTreeEvent.value.consuming) {
        const createdEvent = result.transactionTree.eventsById["1"];

        if (RedstoneCommon.isDefined(createdEvent) && "CreatedTreeEvent" in createdEvent) {
          return makeActiveContractData(
            createdEvent.CreatedTreeEvent.value,
            result.transactionTree.synchronizerId
          ) as unknown as Res;
        }
      }

      return excerciseEvent.ExercisedTreeEvent.value.exerciseResult as Res;
    }

    throw new Error(RedstoneCommon.stringify(excerciseEvent));
  }

  private async performRequest<T>(promise: () => Promise<T | JsCantonError>) {
    OpenAPI.BASE = this.baseUrl;
    OpenAPI.TOKEN = this.tokenProvider;

    return await unwrapResponse(promise());
  }
}
