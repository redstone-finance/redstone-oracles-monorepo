import { loggerFactory, RedstoneCommon } from "@redstone-finance/utils";
import {
  DefaultService,
  DisclosedContract,
  JsCantonError,
  OpenAPI,
  TransactionFormat,
} from "./_autogenerated";
import type { ApiRequestOptions } from "./_autogenerated/core/ApiRequestOptions";
import { CantonNetwork } from "./CantonNetwork";
import * as AllDefs from "./contracts.json";
import {
  isCreatedEvent,
  isJsActiveContractEntry,
  isTransactionUpdate,
  makeActiveContractData,
  makeInterfaceFilterByParty,
  unwrapResponse,
} from "./utils";

export type ContractFilter = (createArgument: unknown) => boolean;

const DEFAULT_DELTA_OFFSET = 1000;
const LOCAL_USER = "redstone-canton-connector";
const MAX_RESPONSE_LIMIT = 200;

const RETRY_CONFIG: Omit<RedstoneCommon.RetryConfig, "fn"> = {
  maxRetries: 3,
  waitBetweenMs: 500,
  backOff: {
    backOffBase: 1.5,
  },
};

const SENDER_SEPARATOR = "/";
export class CantonClient {
  private readonly logger = loggerFactory("canton-client");

  Defs: (typeof AllDefs)["mainnet"];

  constructor(
    readonly partyId: string,
    private readonly baseUrl: string,
    network: CantonNetwork = "localnet",
    private readonly tokenProvider?: (options: ApiRequestOptions) => Promise<string>
  ) {
    this.Defs = AllDefs[network];
  }

  async getCurrentOffset() {
    return (await this.performRequest(DefaultService.getV2StateLedgerEnd, "getCurrentOffset"))
      .offset;
  }

  private async fetchActiveContracts(
    interfaceId: string,
    filter?: ContractFilter,
    atOffset?: number,
    limit = MAX_RESPONSE_LIMIT
  ) {
    const { filtersByParty, offset } = await this.resolveFilterAndOffset(interfaceId, atOffset);
    const contracts = await this.performRequest(
      () =>
        DefaultService.postV2StateActiveContracts(
          {
            filter: { filtersByParty },
            activeAtOffset: offset,
            verbose: false,
          },
          limit
        ),
      `postV2StateActiveContracts ${RedstoneCommon.stringify(filtersByParty)}`
    );

    return contracts.filter(
      (contract) =>
        isJsActiveContractEntry(contract.contractEntry) &&
        (!filter || filter(contract.contractEntry.JsActiveContract.createdEvent.createArgument))
    );
  }

  async getActiveContractsData(
    interfaceId: string,
    filter?: ContractFilter,
    atOffset?: number,
    limit = MAX_RESPONSE_LIMIT
  ) {
    return await this.fetchActiveContracts(interfaceId, filter, atOffset, limit);
  }

  async getActiveContractData(interfaceId: string, filter?: ContractFilter, atOffset?: number) {
    const adapters = await this.fetchActiveContracts(interfaceId, filter, atOffset);

    if (adapters.length === 0) {
      throw new Error("No active contract data");
    }
    const [adapter, ...rest] = adapters;
    if (rest.length > 0 || !isJsActiveContractEntry(adapter.contractEntry)) {
      throw new Error(`Unable to determine contract data: ${RedstoneCommon.stringify(adapters)}`);
    }

    const { createdEvent, synchronizerId } = adapter.contractEntry.JsActiveContract;

    return makeActiveContractData(createdEvent, synchronizerId);
  }

  async getCreateContractEvents(
    interfaceId: string,
    filter?: ContractFilter,
    atOffset?: number,
    deltaOffset = DEFAULT_DELTA_OFFSET,
    excludeArchived = false
  ) {
    const { filtersByParty, offset } = await this.resolveFilterAndOffset(interfaceId, atOffset);
    const contracts = await this.fetchUpdates(
      filtersByParty,
      Math.max(0, offset - deltaOffset),
      TransactionFormat.transactionShape.TRANSACTION_SHAPE_ACS_DELTA
    );

    const transactions = contracts
      .map((contract) =>
        isTransactionUpdate(contract.update) ? contract.update.Transaction : undefined
      )
      .filter(RedstoneCommon.isDefined);

    const archivedContractIds = excludeArchived
      ? new Set(
          transactions
            .flatMap((transaction) => transaction.value.events ?? [])
            .filter((event) => "ArchivedEvent" in event)
            .map((event) => event.ArchivedEvent.contractId)
        )
      : new Set();

    const createdEvents = transactions
      .map((transaction) => transaction.value.events?.filter((event) => isCreatedEvent(event)))
      .filter((list) => list?.length)
      .filter(RedstoneCommon.isDefined);

    return createdEvents
      .flat()
      .filter((createdEvent) => !filter || filter(createdEvent.CreatedEvent.createArgument))
      .map((createdEvent) => createdEvent.CreatedEvent)
      .filter((createdEvent) => !archivedContractIds.has(createdEvent.contractId));
  }

  async getGetPricesTransactions(interfaceId: string, from: number, to: number) {
    const filtersByParty = makeInterfaceFilterByParty(interfaceId, this.partyId);
    const result = await this.fetchUpdates(
      filtersByParty,
      Math.max(0, from),
      TransactionFormat.transactionShape.TRANSACTION_SHAPE_LEDGER_EFFECTS,
      to
    );

    const updates = [];

    for (const { update } of result) {
      if (!("Transaction" in update)) {
        continue;
      }

      const events = update.Transaction.value.events!;

      for (const event of events) {
        if (!("ExercisedEvent" in event) || event.ExercisedEvent.choice !== "GetPricesFeatured") {
          continue;
        }

        if (!("payloadHex" in event.ExercisedEvent.choiceArgument)) {
          continue;
        }

        const choice = event.ExercisedEvent.choiceArgument as { payloadHex: string };

        const arg = choice.payloadHex;
        const block = event.ExercisedEvent.offset;
        const timeSecs = RedstoneCommon.msToSecs(Date.parse(update.Transaction.value.recordTime));
        const to = event.ExercisedEvent.contractId;
        const from = event.ExercisedEvent.actingParties?.join(SENDER_SEPARATOR) ?? "";

        const updateId = update.Transaction.value.updateId;

        updates.push({ arg, block, timeSecs, from, to, updateId });
      }
    }

    return updates;
  }

  async exerciseChoice<Arg extends object, Res = object>(
    command: { templateId: string; contractId: string; choice: string; choiceArgument: Arg },
    timestamp: Date,
    disclosedContracts?: DisclosedContract[]
  ): Promise<Res> {
    const results = await this.exerciseChoices<Arg, Res>([command], timestamp, disclosedContracts);
    const [result] = Object.values(results);

    if (!result) {
      throw new Error(`No result for choice ${command.choice} on contract ${command.contractId}`);
    }

    return result;
  }

  async exerciseChoicesWithoutWaiting<Arg extends object>(
    commands: { templateId: string; contractId: string; choice: string; choiceArgument: Arg }[],
    timestamp: Date,
    disclosedContracts?: DisclosedContract[]
  ) {
    const choices = [...new Set(commands.map((c) => c.choice))].join(",");
    const commandId = `batch-${choices}-${timestamp.getTime()}`;

    await this.performRequest(
      () =>
        DefaultService.postV2CommandsAsyncSubmit({
          commands: commands.map((command) => ({ ExerciseCommand: command })),
          commandId,
          actAs: [this.partyId],
          disclosedContracts,
          userId: !this.tokenProvider ? LOCAL_USER : undefined,
        }),
      `postV2CommandsAsyncSubmit batch[${commands.length}]`
    );

    return commandId;
  }

  async exerciseChoices<Arg extends object, Res = object>(
    commands: { templateId: string; contractId: string; choice: string; choiceArgument: Arg }[],
    timestamp: Date,
    disclosedContracts?: DisclosedContract[]
  ) {
    const choices = [...new Set(commands.map((c) => c.choice))].join(",");

    const result = await this.performRequest(
      () =>
        DefaultService.postV2CommandsSubmitAndWaitForTransaction({
          commands: {
            commands: commands.map((command) => ({ ExerciseCommand: command })),
            commandId: `batch-${choices}-${commands.length}-${timestamp.getTime()}`,
            actAs: [this.partyId],
            disclosedContracts,
            userId: !this.tokenProvider ? LOCAL_USER : undefined,
          },
          transactionFormat: {
            transactionShape: TransactionFormat.transactionShape.TRANSACTION_SHAPE_LEDGER_EFFECTS,
            eventFormat: {
              filtersByParty: { [this.partyId]: {} },
              verbose: false,
            },
          },
        }),
      `postV2CommandsSubmitAndWaitForTransaction batch[${commands.length}]`
    );

    const { events, synchronizerId } = result.transaction;
    if (!RedstoneCommon.isDefined(events)) {
      throw new Error(`field events undefined even though explicitly requested`);
    }
    const results: Record<string, Res> = {};

    for (const event of events) {
      if (!("ExercisedEvent" in event)) {
        continue;
      }

      const exercisedEvent = event.ExercisedEvent;

      if (exercisedEvent.consuming) {
        const createdEvent = events.find(
          (e) =>
            "CreatedEvent" in e &&
            e.CreatedEvent.nodeId > exercisedEvent.nodeId &&
            e.CreatedEvent.nodeId <= exercisedEvent.lastDescendantNodeId
        );

        if (createdEvent && "CreatedEvent" in createdEvent) {
          const newContractId = createdEvent.CreatedEvent.contractId;
          results[newContractId] = makeActiveContractData(
            createdEvent.CreatedEvent,
            synchronizerId
          ) as unknown as Res;
          continue;
        }
      }

      results[exercisedEvent.contractId] = exercisedEvent.exerciseResult as Res;
    }

    return results;
  }

  private async resolveFilterAndOffset(interfaceId: string, atOffset?: number) {
    const filtersByParty = makeInterfaceFilterByParty(interfaceId, this.partyId);
    const offset = atOffset ?? (await this.getCurrentOffset());

    return { filtersByParty, offset };
  }

  private async fetchUpdates(
    filtersByParty: Record<string, object>,
    beginExclusive: number,
    transactionShape: TransactionFormat.transactionShape,
    endInclusive?: number
  ) {
    return await this.performRequest(
      () =>
        DefaultService.postV2Updates({
          beginExclusive,
          endInclusive,
          verbose: false,
          updateFormat: {
            includeTransactions: {
              eventFormat: { filtersByParty, verbose: false },
              transactionShape,
            },
          },
        }),
      `postV2Updates ${RedstoneCommon.stringify(filtersByParty)}`
    );
  }

  private async performRequest<T>(
    promise: () => Promise<T | JsCantonError>,
    fnName = "performRequest"
  ) {
    OpenAPI.BASE = this.baseUrl;
    OpenAPI.TOKEN = this.tokenProvider;

    this.logger.info(`Calling ${fnName}`);

    return await RedstoneCommon.retry({
      ...RETRY_CONFIG,
      fn: () => unwrapResponse(promise()),
      logger: this.logger.log.bind(this),
      fnName,
    })();
  }
}
