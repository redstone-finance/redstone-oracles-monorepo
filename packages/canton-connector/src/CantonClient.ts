import { RedstoneCommon } from "@redstone-finance/utils";
import { DefaultService, DisclosedContract, JsCantonError, OpenAPI } from "./_autogenerated";
import type { ApiRequestOptions } from "./_autogenerated/core/ApiRequestOptions";
import * as AllDefs from "./contracts.json";
import {
  isJsActiveContractEntry,
  makeActiveContractData,
  makeInterfaceFilterByParty,
  unwrapResponse,
} from "./utils";

export const CantonNetworks = ["devnet", "mainnet"] as const;
export type CantonNetwork = (typeof CantonNetworks)[number];

export class CantonClient {
  Defs: (typeof AllDefs)["mainnet"];

  constructor(
    readonly partyId: string,
    private readonly baseUrl: string,
    private readonly tokenProvider: undefined | ((options: ApiRequestOptions) => Promise<string>),
    network: CantonNetwork = "devnet",
    private readonly userId: string | undefined = undefined
  ) {
    this.Defs = AllDefs[network];
  }

  async getCurrentOffset() {
    return (await this.performRequest(DefaultService.getV2StateLedgerEnd)).offset;
  }

  async getActiveContractData<T>(interfaceId: string, filter?: (createArgument: T) => boolean) {
    const filtersByParty = makeInterfaceFilterByParty(interfaceId, this.partyId);
    const offset = await this.getCurrentOffset();
    const contracts = await this.performRequest(() =>
      DefaultService.postV2StateActiveContracts({
        filter: {
          filtersByParty,
        },
        activeAtOffset: offset,
        verbose: false,
      })
    );

    const adapters = contracts.filter(
      (contract) =>
        isJsActiveContractEntry(contract.contractEntry) &&
        (!filter ||
          filter(contract.contractEntry.JsActiveContract.createdEvent.createArgument as T))
    );

    if (adapters.length === 1 && isJsActiveContractEntry(adapters[0].contractEntry)) {
      const jsActiveContract = adapters[0].contractEntry.JsActiveContract;
      return makeActiveContractData(jsActiveContract.createdEvent, jsActiveContract.synchronizerId);
    }

    throw new Error(`Unable to determine contract data: ${RedstoneCommon.stringify(contracts)}`);
  }

  async exerciseChoice<Arg extends object, Res = object>(
    command: { templateId: string; contractId: string; choice: string; choiceArgument: Arg },
    timestamp: Date,
    disclosedContracts?: DisclosedContract[]
  ) {
    const result = await this.performRequest(() =>
      // eslint-disable-next-line @typescript-eslint/no-deprecated -- needed and available for 3.4.9 for now
      DefaultService.postV2CommandsSubmitAndWaitForTransactionTree({
        commands: [
          {
            ExerciseCommand: command,
          },
        ],
        commandId: `${command.contractId}-${command.choice}-${timestamp.getTime()}`,
        actAs: [this.partyId],
        disclosedContracts,
        userId: this.userId,
      })
    );

    const excerciseEvent = result.transactionTree.eventsById["0"];
    if ("ExercisedTreeEvent" in excerciseEvent) {
      if (excerciseEvent.ExercisedTreeEvent.value.consuming) {
        const createdEvent = result.transactionTree.eventsById["1"];

        if (RedstoneCommon.isDefined(createdEvent) && "CreatedTreeEvent" in createdEvent) {
          return makeActiveContractData(
            createdEvent.CreatedTreeEvent.value,
            result.transactionTree.synchronizerId
          ) as unknown as Res;
        }
      }

      return excerciseEvent.ExercisedTreeEvent.value.exerciseResult as Res;
    }

    throw new Error(RedstoneCommon.stringify(excerciseEvent));
  }

  private async performRequest<T>(promise: () => Promise<T | JsCantonError>) {
    OpenAPI.BASE = this.baseUrl;
    OpenAPI.TOKEN = this.tokenProvider;

    return await unwrapResponse(promise());
  }
}
