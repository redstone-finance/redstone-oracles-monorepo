import { loggerFactory, RedstoneCommon } from "@redstone-finance/utils";
import {
  DefaultService,
  DisclosedContract,
  JsCantonError,
  OpenAPI,
  TransactionFormat,
} from "./_autogenerated";
import type { ApiRequestOptions } from "./_autogenerated/core/ApiRequestOptions";
import { CantonNetwork } from "./CantonNetwork";
import * as AllDefs from "./contracts.json";
import {
  isCreatedEvent,
  isJsActiveContractEntry,
  isTransactionUpdate,
  makeActiveContractData,
  makeInterfaceFilterByParty,
  unwrapResponse,
} from "./utils";

export type ContractFilter = (createArgument: unknown) => boolean;

const DEFAULT_DELTA_OFFSET = 1000;
const LOCAL_USER = "redstone-canton-connector";

const RETRY_CONFIG: Omit<RedstoneCommon.RetryConfig, "fn"> = {
  maxRetries: 3,
  waitBetweenMs: 500,
  backOff: {
    backOffBase: 1.5,
  },
};

export class CantonClient {
  private readonly logger = loggerFactory("canton-client");

  Defs: (typeof AllDefs)["mainnet"];

  constructor(
    readonly partyId: string,
    private readonly baseUrl: string,
    network: CantonNetwork = "localnet",
    private readonly tokenProvider?: (options: ApiRequestOptions) => Promise<string>
  ) {
    this.Defs = AllDefs[network];
  }

  async getCurrentOffset() {
    return (await this.performRequest(DefaultService.getV2StateLedgerEnd, "getCurrentOffset"))
      .offset;
  }

  async getActiveContractData(interfaceId: string, filter?: ContractFilter, atOffset?: number) {
    const filtersByParty = makeInterfaceFilterByParty(interfaceId, this.partyId);
    const offset = atOffset ?? (await this.getCurrentOffset());
    const contracts = await this.performRequest(
      () =>
        DefaultService.postV2StateActiveContracts({
          filter: {
            filtersByParty,
          },
          activeAtOffset: offset,
          verbose: false,
        }),
      `postV2StateActiveContracts  ${RedstoneCommon.stringify(filtersByParty)}`
    );

    const adapters = contracts.filter(
      (contract) =>
        isJsActiveContractEntry(contract.contractEntry) &&
        (!filter || filter(contract.contractEntry.JsActiveContract.createdEvent.createArgument))
    );

    if (adapters.length === 1 && isJsActiveContractEntry(adapters[0].contractEntry)) {
      const jsActiveContract = adapters[0].contractEntry.JsActiveContract;
      return makeActiveContractData(jsActiveContract.createdEvent, jsActiveContract.synchronizerId);
    }

    throw new Error(`Unable to determine contract data: ${RedstoneCommon.stringify(contracts)}`);
  }

  async getCreateContractEvents(
    interfaceId: string,
    filter?: ContractFilter,
    atOffset?: number,
    deltaOffset = DEFAULT_DELTA_OFFSET
  ) {
    const filtersByParty = makeInterfaceFilterByParty(interfaceId, this.partyId);
    const offset = atOffset ?? (await this.getCurrentOffset());
    const contracts = await this.performRequest(
      () =>
        DefaultService.postV2Updates({
          beginExclusive: Math.max(0, offset - deltaOffset),
          verbose: false,
          updateFormat: {
            includeTransactions: {
              eventFormat: { filtersByParty, verbose: false },
              transactionShape: TransactionFormat.transactionShape.TRANSACTION_SHAPE_ACS_DELTA,
            },
          },
        }),
      `postV2Updates ${RedstoneCommon.stringify(filtersByParty)}`
    );

    const createdEvents = contracts
      .map((contract) =>
        isTransactionUpdate(contract.update) ? contract.update.Transaction : undefined
      )
      .filter(RedstoneCommon.isDefined)
      .map((transaction) => transaction.value.events?.filter((event) => isCreatedEvent(event)))
      .filter((list) => list?.length)
      .filter(RedstoneCommon.isDefined);

    return createdEvents
      .flat()
      .filter((createdEvent) => !filter || filter(createdEvent.CreatedEvent.createArgument))
      .map((createdEvent) => createdEvent.CreatedEvent);
  }

  async exerciseChoice<Arg extends object, Res = object>(
    command: { templateId: string; contractId: string; choice: string; choiceArgument: Arg },
    timestamp: Date,
    disclosedContracts?: DisclosedContract[]
  ): Promise<Res> {
    const results = await this.exerciseChoices<Arg, Res>([command], timestamp, disclosedContracts);
    const [result] = Object.values(results);

    if (!result) {
      throw new Error(`No result for choice ${command.choice} on contract ${command.contractId}`);
    }

    return result;
  }

  async exerciseChoices<Arg extends object, Res = object>(
    commands: { templateId: string; contractId: string; choice: string; choiceArgument: Arg }[],
    timestamp: Date,
    disclosedContracts?: DisclosedContract[]
  ): Promise<Record<string, Res>> {
    const choices = [...new Set(commands.map((c) => c.choice))].join(",");
    const result = await this.performRequest(
      () =>
        // eslint-disable-next-line @typescript-eslint/no-deprecated -- needed and available for 3.4.9 for now
        DefaultService.postV2CommandsSubmitAndWaitForTransactionTree({
          commands: commands.map((command) => ({ ExerciseCommand: command })),
          commandId: `batch-${choices}-${commands.length}-${timestamp.getTime()}`,
          actAs: [this.partyId],
          disclosedContracts,
          userId: !this.tokenProvider ? LOCAL_USER : undefined,
        }),
      `postV2CommandsSubmitAndWaitForTransactionTree batch[${commands.length}]`
    );

    const { eventsById, synchronizerId } = result.transactionTree;
    const events = Object.values(eventsById);
    const results: Record<string, Res> = {};

    for (const event of events) {
      if (!("ExercisedTreeEvent" in event)) {
        continue;
      }

      const exercisedEvent = event.ExercisedTreeEvent.value;

      if (exercisedEvent.consuming) {
        const createdEvent = events.find(
          (e) =>
            "CreatedTreeEvent" in e &&
            e.CreatedTreeEvent.value.nodeId > exercisedEvent.nodeId &&
            e.CreatedTreeEvent.value.nodeId <= exercisedEvent.lastDescendantNodeId
        );

        if (createdEvent && "CreatedTreeEvent" in createdEvent) {
          const newContractId = createdEvent.CreatedTreeEvent.value.contractId;
          results[newContractId] = makeActiveContractData(
            createdEvent.CreatedTreeEvent.value,
            synchronizerId
          ) as unknown as Res;
          continue;
        }
      }

      results[exercisedEvent.contractId] = exercisedEvent.exerciseResult as Res;
    }

    return results;
  }

  private async performRequest<T>(
    promise: () => Promise<T | JsCantonError>,
    fnName = "performRequest"
  ) {
    OpenAPI.BASE = this.baseUrl;
    OpenAPI.TOKEN = this.tokenProvider;

    this.logger.info(`Calling ${fnName}`);

    return await RedstoneCommon.retry({
      ...RETRY_CONFIG,
      fn: () => unwrapResponse(promise()),
      logger: this.logger.log.bind(this),
      fnName,
    })();
  }
}
