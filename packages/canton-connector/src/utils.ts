import { RedstoneCommon } from "@redstone-finance/utils";
import axios from "axios";
import z from "zod";
import {
  ApiError,
  CreatedEvent,
  JsCantonError,
  JsContractEntry,
  Map_Filters,
} from "./_autogenerated";

export type DamlTuple2<T = string, U = string> = { _1: T; _2: U };

const CONTRACT_NOT_FOUND_ERROR = "CONTRACT_NOT_FOUND";

export function isContractNotFoundError(e: unknown): e is ApiError & { body: { code: string } } {
  const error = e as Error & { body: { code: string } };

  return error.body.code === CONTRACT_NOT_FOUND_ERROR;
}

export async function unwrapResponse<T>(promise: Promise<T | JsCantonError>) {
  const response = await promise;

  if (typeof response === "object" && response !== null && "code" in response) {
    throw new Error(response.cause);
  }

  return response;
}

export function makeInterfaceFilterByParty(interfaceId: string, partyId: string) {
  const partyFilter = {
    cumulative: [
      {
        identifierFilter: {
          InterfaceFilter: {
            value: {
              interfaceId,
              includeInterfaceView: true,
              includeCreatedEventBlob: true,
            },
          },
        },
      },
    ],
  };

  const filtersByParty: Map_Filters = {};
  filtersByParty[partyId] = partyFilter;

  return filtersByParty;
}

export function isJsActiveContractEntry(contractEntry: JsContractEntry) {
  return "JsActiveContract" in contractEntry;
}

export interface ActiveContractData {
  contractId: string;
  synchronizerId?: string;
  createdEventBlob?: string;
}

export function makeActiveContractData(
  createdEvent: CreatedEvent,
  synchronizerId: string = ""
): ActiveContractData {
  return {
    contractId: createdEvent.contractId,
    synchronizerId,
    createdEventBlob: RedstoneCommon.useDefaultIfEmpty(createdEvent.createdEventBlob, undefined),
  };
}

export async function keycloakTokenProvider(opts?: {
  url: string;
  realm: string;
  clientId: string;
  username: string;
  password: string;
}) {
  const { url, realm, clientId, username, password } = opts ?? readKeycloakOpts();

  const { data } = await axios.post<{ access_token: string }>(
    `${url}/auth/realms/${realm}/protocol/openid-connect/token`,
    {
      grant_type: "password",
      client_id: clientId,
      username: username,
      password: password,
    },
    {
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
      },
    }
  );

  return data.access_token;
}

function readKeycloakOpts() {
  return {
    url: RedstoneCommon.getFromEnv("KEYCLOAK_URL", z.url()),
    realm: RedstoneCommon.getFromEnv("REALM"),
    clientId: RedstoneCommon.getFromEnv("CLIENT_ID"),
    username: RedstoneCommon.getFromEnv("KEYCLOAK_USERNAME"),
    password: RedstoneCommon.getFromEnv("KEYCLOAK_PASSWORD"),
  };
}

export function readPartyId() {
  return {
    viewerPartyId: RedstoneCommon.getFromEnv("VIEWER_PARTY_ID"),
    updaterPartyId: RedstoneCommon.getFromEnv("UPDATER_PARTY_ID"),
  };
}

export function readPartySuffix() {
  return RedstoneCommon.getFromEnv("PARTY_SUFFIX");
}
